# RKA


## Recoverable Key Agreement

This protocol allows to generate a recoverable secret key for two participants and allows its recoverability for a trusted-third-party. This protocol is the core of the "Auditable, Recoverable and Distributed Key Agreement for Medical Data Sharing" protocol that was published at the 6th Conference on Blockchain Research & Applications for Innovative Networks and Services (BRAINS) - ["Auditable Medical Data Sharing through Recoverable Key Agreement"](https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=10732363) - or [via TU Delft Repository - open-access](https://repository.tudelft.nl/file/File_4af7eaec-735e-4330-aa27-bf8d5e63417e)

The protocl combines HMQV, EC-KEM and ECDSA protocols.
This is a Golang implementation of our Auditable, Recoverable and Distributed Key Agreement for Medical Data Sharing (ARDKA) protocol. To note that the distributed feature is "simulated" for a real use case scenario the implementation of the interactions with a distributed ledger is required.   

The core repository is also available at [septoneu/ardka](https://github.com/septoneu/ardka).

## Dependence 

The implementation uses the standard and supplementary Go cryptography libraries.

To use our implementation the `golang.org/x/crypto` is also required. To get `golang.org/x/crypto` please library use:

```bash 
go get -u golang.org/x/crypto 
```

## How to Use ?

Some notes: the protocol is run between two parties Alice and Bob. 
Alice has `(a,A)` - static (longterm) private/public key pair and she generates `(x,X)` Ephemeral key for each session of communication.
Bob has `(b,B)` - static (longterm) private/public key pair and he generates `(y,Y)` Ephemeral key for each session of communication.

To note: `\hat{B}` and ` \hat{A}` are the static public keys.


By running:

```bash 
go run ardka.go
```

To note, the HMQV protocol is executed among the two parties:
```go 
Agree(staticKeys *StaticKeys, ephemeralKeys *EphemeralKeys, staticOtherKeys *StaticKeys, ephemeralOtherKeys *EphemeralKeys, role bool)
```
when role is set to `True`:
```
sigma_A = (Y . B^{e})^{x + d.a mod q}
```

when role is set to `False` the protocol computes: 
```
sigma_B = (X \cdot A^{d})^{y + e.b mod q }
```

To run it only at one parties side just uncomment one of the following lines:
```go
Km1 := hmqv.Agree(&staticKeysAlice, &ephemeralKeysAlice, &staticKeysBob, &ephemeralKeysBob, true)
Km2 := hmqv.Agree(&staticKeysBob, &ephemeralKeysBob, &staticKeysAlice, &ephemeralKeysAlice, false)
```

To note: when only one party will be run, the private key of the other party is unknown, therefore, it can be set to `nil`. For exemple when only Alice runs the HMQV protocol the following call can be applied:
```go
Km1 := hmqv.Agree(&staticKeysAlice, &ephemeralKeysAlice, nil, &ephemeralKeysBob, true)
```

## Test HMQV and EC_KEM modules
As these two modules are the main building blocks of our protocol, they are also available separately and they can be tested in main() functions.
These two modules are under `\test_blocks` folder.  

## RUn Benchmarks
To generate benchmarking metrics, ardka_test.go defines 6 functions. Results can be generated by running:
```fish
go test -bench . -benchmem -benchtime 10000x -count 5 > results/(date  -u +%Y%m%d_%H%M%S)ardka_benchmark.txt
```

